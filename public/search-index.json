[{"slug":"golang-tips","category":"notes","title":"Golang Tips","tags":["draft","golang"],"body":"\r\n# Variáveis de ambiente do golang\r\n\r\n| Variável   | Descrição                                                                 |\r\n| ---------- | ------------------------------------------------------------------------- |\r\n| GOMAXPROCS | configura o numero maximo de processos que podem ser criados pela runtime |\r\n"},{"slug":"golang","category":"notes","title":"Golang - Guia básico","tags":["draft","golang","programming languages"],"body":"\r\n## Caracteristicas\r\n- linguagem compilada direto para binário\r\n- binário grande\r\n- linguagem simples \r\n- projetada para concorrencia\r\n- variáveis ou métodos criados PRECISAM ser utilizados ou não irá compilar \r\n- [como instalar em qualquer plataforma](http://go.dev/doc/install)\r\n\r\n### Padrões de uso da linguagem\r\n- letra inicial maiúscula em uma função determina que ela será publica\r\n- não há getters nem setters, caso necessário uso de um get, utilize a declaracao do campo com letra minuscula e crie um método com o mesmo nome do campo porém com letra maiúscula, desta forma a função será exportado e quem utilizar não verá diferença, para o setter, utilize o padrão SetCampo para alterar o valor do campo caso necessário\r\n- ao nomear interfaces utilize verbos, Reader, Writter..., assim o método será o substantivo daquele verbo (Read, Write)\r\n- caso implemente uma conversão para um tipo conhecido, utilize o nome do tipo diretamente exemplo: String() e não ToString()\r\n- nomes de pacotes dever ser pequenos\r\n- utilize MixedCaps como padrão, iniciando ou não com maiúscula conforme visibilidade do médoto ou variável\r\n- estrutura de projeto\r\n``` yaml\r\nmoduleFolder:\r\n  cmd:\r\n    # como os pacotes são exportados individualmente\r\n    # o main fica separado para quem importar poder executar seu próprio main\r\n    - main.go       \r\n```\r\n\r\n### Módulos & Pacotes\r\n``` yaml\r\nModulo: Coleção de pacotes\r\n  - Pacote:\r\n    - file.go\r\n  - Pacote:\r\n    - file.go\r\n    - file.go\r\n```\r\nComo criar um módulo\r\n```sh\r\ngo mod init myModule # ou github.com/<user>/<repo_do_modulo>\r\n```\r\noutput\r\n``` sh\r\nmodule myModule\r\n\r\ngo 1.23 # active version\r\n```\r\n\r\n\r\nPacote Main <br>\r\ntodo pacote main precisa ter uma funcao chamada main, caso contrato terá um erro de compilação\r\n\r\n``` go\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main(){\r\n  fmt.Println(\"Hello World!\")\r\n}\r\n```\r\n\r\nExecutar um programa go\r\n\r\n``` sh\r\n# somente compilação (vai gerar o binário)\r\ngo build cmd/main.go\r\n# execução do binário\r\n./main\r\n# ou compilar e executar consecutivamente com o comando run\r\ngo run cmd/main.go\r\n```\r\n\r\n### Tipos\r\n\r\n### Tipos da dados básicos\r\n``` yaml\r\nBooleano: \r\n  Default: false\r\n  - bool: true ou false\r\nPonto Flutuante:\r\n  Dafault: 0.0\r\n  - float32: 32 bits = -3.4e+38 to 3.4e+38\r\n  - float64: 64 bits = -1.7e+308 to +1.7e+308\r\nCaracter:\r\n  Default: 0\r\n  - byte: alias for uint8\r\n  - rune: alias for int32\r\nTexto:\r\n  Default: ''\r\n  - string: coleção de bytes UTF-8\r\nInteiro:\r\n  Default: 0\r\n  - int: tamanho depende da arquitetura do sistema 32 ou 64 bits\r\n  - int8: min -128 | max = -127\r\n  - int16: min = -32768 | max = -32767\r\n  - int32: min = -2147483648 | max = -2147483647\r\n  - int64: min = -9223372036854775808 | max = -9223372036854775807\r\n  - uint: 'u' vem de unassigned (sem atribuição de sinal) \r\n  - uint8: min = 0 | max = -255\r\n  - uint16: min = 0 | max = -65535\r\n  - uint32: min = 0 | max = -4294967295\r\n  - uint64: min = 0 | max = -18446744073709551615\r\n```\r\n\r\n#### Tipos de variáveis\r\n``` go\r\nconst myConst // imutável ou constante\r\nvar myVar  // mutável porém de tipagem forte e estática\r\n\r\nmyVar = \"some value\" // tipo inferido (string)\r\nmyVar = 10 // erro \r\n```\r\n\r\n### Declaração de variáveis\r\n``` go\r\nvar intNum int\r\nanotherInt := 0\r\nvar some, other = 1, 2\r\nlook, again := 3, 4\r\n// only one way for constants, sorry\r\n```\r\n\r\n### STRINGS, RUNES & BYTES\r\nStrings em go são imutáveis e naturalmente UTF-8, e ocupam 7 bits + 1 bit de sinal, porém UTF-8 tem um encoding dinâmico que pode se extender até 32 bits, cobrindo UTF-32, e podendo armazenar caracteres chineses, emojis e outros símbolos,\r\n\r\nStrings em go são uma coleção de Runas ou uint8 devido o encoding, porém\r\n``` go\r\nvar simpleString string = \"Hello \\nworld!\"\r\nvar stringBlock string = `Hello\r\nworld!`\r\n\r\nfmt.Println(simpleString) // mesmo resultado\r\nfmt.Println(stringBlock) // nos dois\r\n\r\nfmt.Println(len(\"atenção\")) // 9 | número de bytes em ASCII 256\r\nfmt.Println(len(\"atencao\")) // 7 | parece estar certo, mas não funciona sempre\r\n\r\nimport \"unicode/utf8\"\r\nfmt.Println(utf8.RuneCountInString(\"atenção\")) // resultado correto sempre\r\n\r\nvar myString = \"atenção\"\r\n// Ao buscar o 'a' teremos o valor correto dele na tabela ascii\r\nvar stringIndex uint8 = myString[0]\r\nfmt.Println(stringIndex) // 97\r\n\r\n// Ao buscar o 'ç' teremos o valor do primeiro byte\r\n// porém como 'ç' precisa de mais de um byte, o valor correto seria 231\r\nvar stringIndex4 uint8 = myString[4]\r\nfmt.Println(stringIndex4) // 167\r\nfor i, v := range myString {\r\n  fmt.Println(i, v)\r\n}\r\n/*\r\n  0 97\r\n  1 116\r\n  2 101\r\n  3 110 \r\n  4 231 <- ocupa o espaço do 4 e do 5\r\n  6 227 <- por isso aqui é 6\r\n  8 111\r\n*/\r\n\r\nvar myRune rune = 'a'\r\nfmt.Println(myRune) // 97 | int32 ele imprime o valor numérico\r\n\r\n// Manipulando Strings\r\nvar strSlice = []string{\"H\", \"e\", \"l\", \"l\", \"o\"}\r\nvar concatStr = \"\"\r\nfor i := range strSlice {\r\n  // podemos fazer uma concatenação básica\r\n  // a cada iteração uma nova string será gerada\r\n  concatStr += strSlice[i]\r\n}\r\n\r\nvar strBuilder strings.Builder\r\nfor i := range strSlice {\r\n  // ou usando um string builder, melhor alternativa\r\n  strBuilder.WriteString(strSlice[i])\r\n}\r\nfmt.Println(strBuilder.String())\r\n```\r\n\r\n### Cálculos básicos\r\n``` go\r\n// cast é necessário para fazer os cálculo\r\nvar numFloat32 float32 = 10.1\r\nvar numInt32 int32 = 2\r\nvar result float32 = numFloat32 + float32(numInt32)\r\nfmt.Println(result)\r\n\r\nvar numInt1 int = 3\r\nvar numInt2 int = 2\r\nfmt.Println(numInt1/numInt2) // 1 | arredondamento para int\r\nfmt.Println(numInt1%numInt2) // 1 | operação com resto de divisão\r\n\r\nvar myBoolean bool = false // como alquer linguagem, simples\r\n```\r\n\r\n### Declarando Funções\r\n\r\n``` go\r\n// Forma comum vista em outras linguagens\r\nfunc functionName(param1 string, param2 int) string {\r\n  return \"result\"\r\n}\r\n\r\n// returnando mais de um resultado\r\nfunc multipleReturns(param1 string, param2 int) (string, int) {\r\n  return \"result\", 10\r\n}\r\n\r\n// ao chamar a funcao devemos receber os dois dados\r\nvar first, second = multipleReturns(\"something\", 1)\r\n\r\nimport \"errors\" // pacote de error da biblioteca padrão\r\n// golang não tem try-catch então todos os errors são tratados no retorno da função\r\nfunc withError(wrong bool) bool, error {\r\n  var err error // default: nil\r\n  if wrong {\r\n    err = errors.New(\"Something went wrong\")\r\n  }\r\n  return err, wrong\r\n}\r\n// devemos receber este erro e verificar se ele tem algo\r\nerr, response := withError(true)\r\n// forma padrão de lidar com erros\r\nif err!=nil {\r\n  fmt.Printf(err.Error())\r\n}\r\n\r\n// ou podemos ignorar este erro explicitamente usando '_' \r\n// por padrão devemos retornar primeiro o erro para que ele não seja ignorado acidentalmente\r\n_, response2 := withError(false)\r\n\r\n// funcoes também podem ser atribuídas a objetos\r\nfunc (b ball) roll() {\r\n  b.position++\r\n}\r\n// assim quando declaramos uma nova bola\r\nnewBall := ball.New()\r\n// temos o método novo acessivel a ele\r\n// isso permite estender estruturas de bibliotecas externas, ou até mesmo internas\r\n// podemos atribuir métodos novos para o tipo string por exemplo\r\nnewBall.roll()\r\n```\r\n\r\n### Outras estruturas de controle\r\n``` go\r\n// if, switch, for, não tem parêntesis\r\nvalue := \"something\"\r\n\r\nif value == \"Hi\" {\r\n  fmt.Println(\"It's hi\")\r\n\r\n  // else if e else, tem que estar na mesma linha das chaves\r\n} else if value != \"something\" {\r\n  fmt.Println(\"it's not something\")\r\n\r\n} else {\r\n  fmt.Println(\"it's \" + value)\r\n}\r\n\r\n// no switch, o break é inplicito sobre cada condição\r\nswitch {\r\ncase value == \"Hi\":\r\n  fmt.Println(\"It's hi\")\r\n\r\ncase value != \"something\":\r\n  fmt.Println(\"it's not something\")\r\n\r\ndefault:\r\n  fmt.Println(\"it's \" + value)\r\n}\r\n\r\n// ele também pode ser condicional, atribuindo uma variável diretamente\r\nswitch value {\r\ncase \"Hi\":\r\n  fmt.Println(\"It's hi\")\r\n\r\n// podendo validar mais de um valor para cada cenário\r\ncase \"another thing\", \"anything\":\r\n  fmt.Println(\"it's not something\")\r\n\r\ndefault:\r\n  fmt.Println(\"it's \" + value)\r\n}\r\n```\r\n\r\n### Estruturas de dados\r\n``` go\r\n// ARRAYS\r\n// Tamanho fixo | mesmo tipo de dados | indexável | contínuo na memória\r\nvar intArr[3]int32\r\nintArr[1] = 123 // atribuindo no index\r\nfmt.Println(intArr[0]) // imprimindo posicao 0\r\nfmt.Println(intArr[1:3]) // imprimindo de 1 até 2 (intervalo aberto no 3)\r\n\r\nfmt.Println(&intArr[0]) // imprimindo o endereço de memória\r\nfmt.Println(&intArr[1]) // assim temos como ver que eles ficam\r\nfmt.Println(&intArr[2]) // um do lado do outro\r\n\r\n// poderiamos ter inicializado o array assim também\r\nanotherIntArr := [3]int32{3, 2, 1}\r\nfmt.Println(anotherIntArr[0:3])\r\n```\r\n``` go\r\n// SLICES\r\n// Wrapper para array, ou um array com funcionalidades extras\r\n// ao omitir o tamanho, temos um slice, que será gerado dinamicamente\r\nintSlice := []int32{1, 2, 3}\r\n// tamanho do array, é a quantidade de items, capacidade, é a memória alocada para o array\r\nfmt.Printf(\"O tamanho do array é %v porém a capacidade é %v = \", len(intSlice), cap(intSlice)) // 3 & 3\r\nfmt.Println(intSlice)\r\n\r\n// podemos adicionar valores extras\r\nintSlice = append(intSlice, 7)\r\n// porém ao exceder a capacidade do array original, a capacidade é DOBRADA\r\n// porém não podemos acessar estes valores que estão fora do array\r\nfmt.Printf(\"O tamanho do array é %v porém a capacidade é %v = \", len(intSlice), cap(intSlice)) // 4 & 6\r\nfmt.Println(intSlice)\r\n\r\n// poderiamos criar um novo array especificando tamanho e capacidade\r\n// make é uma função 'fábrica' para os tipos básicos\r\n// int[] é o tipo, 3 o tamanho, 8 a capacidade\r\nvar intSlice2 []int32 = make([]int32, 3, 8)\r\n\r\n// podemos inserir os dados no FIM de outro array via funcao append com o operador spread (...)\r\nintSlice2[0] = 10\r\nintSlice2 = append(intSlice, intSlice2...) // [10, 0, 0, 1, 2, 3, 7]\r\nfmt.Println(intSlice2)\r\n\r\n// iterando...\r\nfor index, value := range intSlice2 {\r\n  fmt.Println(\"Index: \" + index + \" Value: \" + value)\r\n}\r\n```\r\n``` go\r\n// MAPS\r\n\r\n// podemos criar um mapa desta forma\r\nvar myMap map[string]uint8 = make(map[string]uint8)\r\nfmt.Println(myMap)\r\n\r\n// ou diretamente atribuindo valores\r\nMyMap2 := map[string]uint8}{\"James\":5 \"Tiberius\":8 \"Kirk\":4 }\r\nfmt.Println(myMap2[\"James\"]) // 7\r\n\r\n// nesse caso, ele retorna o valor padrão do tipo, nesse caso do uint8 é 0\r\nfmt.Println(myMap2[\"Spock\"])\r\n// podemos deletar um valor usando a funcao delete\r\ndelete(myMap2, \"Tiberius\")\r\n\r\n// para saber se o valor estava no mapa ou ele era realmente 0\r\n// temos um segundo no mapa\r\nvar nameLen, found = myMap2[\"Spock\"] // 0 & false\r\nif  found {\r\n  fmt.Println(\"The name length is \" + nameLen)\r\n}\r\n\r\n// iterando...\r\nfor key, value := range myMap2 {\r\n  fmt.Println(\"Name: \" + key + \" Name length: \" + value)\r\n}\r\n```\r\n\r\n### Iterando\r\nponto importante, golang não tem 'while', então existem variações no for para lidar com todos os cenários necessários\r\n``` go\r\n// Loop basico 'while'\r\nvar i int = 0\r\nfor i<10 {\r\n  fmt.Println(i)\r\n  i += 1\r\n}\r\n\r\n// Loop sem condição \r\ni=0 // resetando\r\nfor {\r\n  // removendo esse if interno, loop infinito\r\n  if i>=10{\r\n    break\r\n  }\r\n  fmt.Println(i)\r\n  i += 1\r\n}\r\n\r\n// for clássico\r\nfor i=0; i<10; i++ {\r\n  fmt.Println(i)\r\n  i += 1\r\n}\r\n\r\n// for range (ou foreach in range)\r\nintSlice := []int32{1, 2, 3}\r\nfor index, value := range intSlice {\r\n  fmt.Println(\"Index: \" + index + \" Value: \" + value)\r\n}\r\n\r\n// podemos ignorar o indice também\r\nfor _, value := range intSlice {\r\n  fmt.Println(\"Index: \" + index + \" Value: \" + value)\r\n}\r\n```\r\n\r\n### Structs & Interfaces\r\nStruct em go nada mais é que um objeto, ele contém atributos e pode conter funções/métodos internos.\r\nMas go é orientado a objetos? Não necessariamente, em go não existe herança.\r\nInterfaces em go tem um comportamento mais 'passivo', ao definir as funções contidas em uma interface, toda struct que conter estas funções vai ser considerada como compatível com a interface, sem a necessidade de explicitamente atribuir a interface para aquela struct, desta forma podemos trabalhar melhor com bibliotecas externas definindo interfaces que seja compatíveis com structs já criadas externamente e criando novas structs compativeis com estas mesmas interfaces\r\n\r\n``` go\r\n// structs podem ser declaradas de forma anonima\r\n// porém assim não podem ser reutilizadas\r\nvar person = struct{\r\n  name string\r\n  age uint8\r\n}{\"Spock\", 83}\r\n\r\n// esta é a forma comum de declarar structs\r\ntype owner struct {\r\n  name string\r\n}\r\n\r\ntype gasCar struct {\r\n  kml     uint8\r\n  tankCap uint8\r\n  owner   // caso tipo e variavel tenham o mesmo nome, podemos omitir\r\n}\r\n\r\n// desta forma atribuimos uma funcao para a struct gasEngine\r\nfunc (e gasCar) kmLeft() uint {\r\n  return uint(e.tankCap) * uint(e.kml)\r\n}\r\n\r\ntype eletricCar struct {\r\n  kpkwh      uint8\r\n  batteryCap uint8\r\n  owner      owner // podemos por ambos sem problemas também\r\n}\r\n\r\n// desta forma atribuimos uma funcao para a struct gasEngine\r\nfunc (e eletricCar) kmLeft() uint {\r\n  return uint(e.batteryCap) * uint(e.kpkwh)\r\n}\r\n\r\n// ao declarar a interface, tanto o carro a gasolina quanto o eletrico\r\n// poderão satisfazer este requisito e serem considerados somente carros\r\ntype car interface {\r\n  kmLeft() uint\r\n}\r\n\r\nfunc willReachDestination(c car, distance uint) bool {\r\n  return c.kmLeft() >= distance\r\n}\r\n\r\nfunc main() {\r\n  // uma struct pode ser inicializada desta forma\r\n  var myCar gasCar = gasCar{kml: 15, tankCap: 40, owner: owner{\"Someone\"}}\r\n  // e ser alterada desta forma (pegando estrada né)\r\n  myCar.kml = 20\r\n  fmt.Println(myCar.kmLeft())\r\n\r\n  // nomes de variáveis podem ser omitidos, enviando os parametros em ordem\r\n  var myOtherCar eletricCar = eletricCar{4, 100, owner{\"Someone\"}}\r\n  fmt.Println(myOtherCar.kmLeft())\r\n\r\n  // ao usar a funcao podemos utilizar ambos os carros\r\n  // pois ambos satisfazem os requisitos da interface\r\n  var distance uint = 500\r\n  fmt.Println(\"Gas Car: \", willReachDestination(myCar, distance))\r\n  fmt.Println(\"Eletric car: \", willReachDestination(myOtherCar, distance))\r\n}\r\n```\r\n\r\n## Tomorrow it's to time for POINTERS\r\n\r\n### TODO LIST\r\n- revisar ortografia\r\n- segmentar melhor os blocos de código\r\n- organizar melhor a ordem dos tópicos\r\n- revisar o tamanho dos títulos\r\n"},{"slug":"how-docker-works","category":"notes","title":"Como Docker funciona","tags":["draft","docker","containers"],"body":"\r\n## O que são Containers?\r\n\r\nContainers são uma forma de virtualização de sistemas operacionais.\r\nCada container é um processo isolado do sistema operacional.\r\nContainers são isolados uns dos outros, mas compartilham o mesmo kernel.\r\nContainers são mais leves que máquinas virtuais por virtualizar somente parte do sistema operacional ao invés de um SO inteiro\r\nContainers são portáteis.\r\nContainers são escaláveis.\r\nContainers são descartáveis.\r\n\r\n### Namespaces\r\n\r\nUsado para isolamento de processos, usuários, rede, file system, etc.\r\ncada container tem seu próprio namespace.\r\n\r\n### Cgroups\r\n\r\nUsado para limitar e isolar recursos, exemplo: Esse processo/namespace vai utilizar só:\r\n\r\n* memory=500mb\r\n* cpu_shares=512\r\n\r\n### Overlay File Systems (OFS)\r\n\r\nUsado para criar e modificar imagens, através deste mecanismo que o docker reutiliza camadas/partes (_layers_) de um uma imagem ou dependências em todos os containers que precisarem, sem a necessidade de duplicar a informação\r\n\r\no container contem uma parte com comada(s) de estado imutável, e uma de leitura e escrita\r\n\r\n### Dockerfile\r\n\r\ndescrição de quais os comandos serão executados ao criar o container para que ele funcione da forma esperada\r\n\r\n``` yaml\r\nFROM: ubuntu:latest\r\nRUN: ./build-script\r\nEXPOSE: 8080\r\n```\r\n\r\na cada nova execucao o Dockerfile é gerada uma nova imagem\r\n\r\ntodas as imagens ficam armazenadas no registry para poderem ser reutilizadas no futuro.\r\n\r\nao executar o Dockerfile, é feito um pull desta imagem\r\n\r\nao efetuar um commit dentro de uma imagem docker, é possivel gerar uma imagem nova a partir de uma já existe em execução, tirando proveito dos dados presentes na camada de leitura e escrita, assim feito um push desta imagem (tipo Git, um grande repo de imagens).\r\n\r\n### Client - Host\r\n\r\n* Host\r\n  * Daemon - API\r\n  * Network (entre containers)\r\n  * Volumes (fora do container, dado persistente)\r\n  * Cache (registry)\r\n\r\n* Client\r\n  * Containers\r\n  * Volumes\r\n  * Network\r\n"},{"slug":"how-use-docker","category":"notes","title":"Como usar o Docker","tags":["draft","docker","containers"],"body":"\r\n## Comandos Docker\r\n\r\nEstado do processo docker (process status - ps)\r\nlista de todos os containers rodando no docker\r\n\r\n``` sh\r\ndocker ps\r\n```\r\n\r\n### Parametros úteis\r\n\r\n| Parametro | Função                                                                       |\r\n| --------- | ---------------------------------------------------------------------------- |\r\n| -a        | incluir containers que não estao mais rodando                                |\r\n| -q        | só o id do container, útil para usar de dado de entrada para outros comandos |\r\n\r\n### Rodando coisas no Docker\r\n\r\nComeçando do básico\r\n\r\n``` sh\r\ndocker run hello-world\r\n```\r\n\r\n### parâmetros úteis\r\n\r\n| Parametro | Função                                               |\r\n| --------- | ---------------------------------------------------- |\r\n| -d        | destravar o terminal e roda o container em backgroud |\r\n| -e        | passar variáveis de ambiente                         |\r\n| -i        | modo interativo, mantém o stdin                      |\r\n| -p        | mapeamento de portas docker -> máquina local         |\r\n| -t        | alocar um tty para acessar o container               |\r\n| -v        | vincular volumes ao container                        |\r\n| -rm       | remove o container assim que ele cair                |\r\n| --name    | define um nome para o container                      |\r\n\r\n\r\nEntrando em um container\r\nobs.:  \"-it\"  ==  \"-i -t\" \r\n\r\n``` sh\r\ndocker run -it ubuntu bash\r\n```\r\n\r\nAcessando localmente algo que está no docker\r\npelo parâmetro -p mapeamos a porta 80 de dentro do docker para a porta 8080 da maquina local\r\n\r\n``` sh\r\ndocker run -p 8080:80 nginx\r\n```\r\n\r\nassim podemos acessar o nginx [localmente através da porta 8080](http://localhost:8080)\r\n\r\n\r\nos containers tambem podem ser nomeados para serem removidos pelo nome dado a eles e nao pelo nome gerado\r\n\r\n``` sh\r\ndocker run -d -p 8080:80 --name server nginx\r\n```\r\n\r\nagora o nginx esta rodando e o container se chama _server_ e pode ser referenciado desta forma.\r\npara acessar um container já em execução, utilizamos o exec\r\n\r\n``` sh\r\ndocker exec -it server bash\r\n```\r\n\r\n### Bind mounts \r\nmapeamento de pastas para dentro de um container atraves de _volumes_\r\nPrimeiro criando um arquivo na máquina local\r\n\r\n```` html\r\n# ~/Projects/files/index.html\r\n<html>\r\n<h1>Custom Server Title</h1>\r\n<br>\r\n<h2>Welcome to the server!!<h2>\r\n</html>\r\n````\r\n\r\ndepois mapeando este volume arquivo para um diretorio dentro do container\r\nObs.: a estrutura do container muda de acordo com a imagem usada, caso nao saiba a estrutura do container em utilizacao, pesquise ou entre nele via bash para ver\r\n\r\n``` sh\r\ndocker run -d -p 8080:80 -v ~/Projects/files/:/usr/share/nginx/html --name server nginx\r\n```\r\n\r\ntip: usar guia anonima para nao ter problemas com cache\r\ntip(2): da pra usar \"$(pwd)\" no path do comando para referenciar o diretorio atual\r\n\r\n\r\nA forma mais elegante e atual de executar essa mesma ação\r\n\r\n``` sh\r\ndocker run -d -p 8080:80 --mount type=bind,source=~/Projects/files/,target=/usr/share/nginx/html --name server nginx\r\n```\r\n\r\ndiferenças: --mount é mais explicito o bind, se o source for incorreto, o -v cria o diretorio novo, o --mount da erro\r\n\r\n### Como criar volumes\r\n\r\n``` sh\r\ndocker create volume meuVolume\r\n```\r\n\r\nagora para ver os detalhes do volume\r\n\r\n``` sh\r\ndocker volume inspect meuVolume  \r\n```\r\n\r\nresultado:\r\n\r\n``` json\r\n[\r\n  {\r\n      \"CreatedAt\": \"2023-09-28T16:40:47-03:00\",\r\n      \"Driver\": \"local\",\r\n      \"Labels\": null,\r\n      \"Mountpoint\": \"/var/lib/docker/volumes/meuVolume/_data\",\r\n      \"Name\": \"meuVolume\",\r\n      \"Options\": null,\r\n      \"Scope\": \"local\"\r\n  }\r\n]\r\n```\r\nagora da pra usar o volume criado igual qualquer outro e estes arquivos vao ser compartilhados pelos containers que utilizarem estes volumes\r\n\r\n``` sh\r\ndocker run -d -p 8080:80 --mount source=meuVolume,target=/app --name server nginx\r\n```\r\nou\r\n``` sh\r\ndocker run -d -p 8080:80 -v meuVolume:/app --name server nginx\r\n```\r\n\r\nporem criando varios volumes, ao longo do tempo vamos tomando muito espaco em disco, para limpar os volumes do docker, use:\r\n\r\n``` sh\r\ndocker volume prune\r\n```\r\n\r\n## Dockerfile\r\n\r\npodemos criar arquivos docker para criar uma imagem personalizada de acordo com a nossa necessidade\r\n\r\n``` yaml\r\n# imagem base usada para a criacao da nova imagem\r\nFROM nginx:latest\r\n\r\n# comandos a serem executados na criacao da imagem\r\nRUN apt update\r\nRUN apt install -y vim\r\n```\r\n\r\npara executarmos este docker file, abrimos o terminal na pasta onde o arquivo se encontra e executamos o comando:\r\n\r\n``` sh\r\ndocker build -t nginx-vim:latest .\r\n```\r\n\r\no parametro '-t' define a tag da imagem, assim como usamos antes o nginx antes, agora temos uma versao do 'nginx' com o vim instalado chamada de 'nginx-vim'\r\n\r\njá o '.' no final se refere a localizacao do arquivo Dockerfile, como estamos com o terminal aberto no mesmo diretorio do arquivo Dockerfile, usamos o ponto, caso nao seja o caso, devemos usar o caminho relativo do arquivo\r\n\r\n...\r\n#### #todo\r\n* ver diferencas de docker [kill | stop | rm];\r\n"},{"slug":"setup-linux-wsl","category":"notes","title":"Setup linux (wsl)","tags":["linux","wsl","ubuntu"],"body":"\n## O que vamos instalar?\n- aliases (apelidos para comandos)\n- Pacotes básicos de sistema\n- Softwares básicos de desennvolvimento\n- Runtimes de linguagens de programação\n- Chave SSH\n\n### Aliases & Path\n<br>\nPrimeiro entre no arquivo de aliases (caso não goste do vim, troque pelo nano ou outro)\n\n``` sh\nsudo apt install -y vim\nvim ~/.bash_aliases\n```\n<br>\nAdicione os atalhos e modifique conforme necessário\n\n``` sh\nalias refresh='source ~/.bashrc && source ~/.bashrc'\nalias config='vim ~/.bash_aliases'\nalias q='exit'\nalias c='clear'\nalias home='cd ~/'\nalias update='sudo apt update && sudo apt -y upgrade'\nalias clean='sudo apt -y autoclean && sudo apt -y autoremove'\n\n# Shortcuts\nalias chrome='google-chrome &'\nalias google='google-chrome &'\n\n\n# PATH\nexport PATH=$PATH:/usr/local/go/bin\n```\n<br>\nagora recarregue o arquivo\n\n``` sh\nsource ~/.bash_aliases\n```\ncom estes aliases fica muito mais fácil daqui para frente\n\n### Pacotes básicos\n``` sh\nupdate\nsudo apt install -y git zip unzip nautilus\n```\n\n<br>\nPara finalizar o git, é necessário configurar as informações do usuário (preencha com seus dados)\n\n``` sh\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"your@email.com\"\n```\n\n### Google Chrome\n``` sh\nrm -rf ~/tmp\nmkdir ~/tmp\ncd ~/tmp\nwget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb\nsudo apt install --fix-missing ./google-chrome-stable_current_amd64.deb\nclean\ncd ..\n```\n### Docker\n``` sh\nsudo apt install -y apt-transport-https ca-certificates curl software-properties-common\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg\necho \"deb [signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null\nupdate\nsudo apt install -y docker-ce docker-ce-cli containerd.io\nsudo usermod -aG docker $USER\n```\n\n<br>\nApós a instalação, como o usuário foi modificado, feche o terminal e abra novamente, em caso de problemas verifique a instalação\n\n``` sh\ndocker --version\n```\n\n### Java\n``` sh\ncurl -s \"https://get.sdkman.io\" | bash\nsource \"$HOME/.sdkman/bin/sdkman-init.sh\"\nsdk install java\njava --version\n```\n\n### Node\n``` sh\ncurl -fsSL https://fnm.vercel.app/install | bash\nsource ~/.bashrc\nfnm install --lts\nnode -v\nnpm -v\nnpm install -g pnpm # Optional\n```\n\n### Golang\n\nPara instalar a versão mais atualizada [verifique no site oficial](https://go.dev/doc/install) a versão atual e atualize o comando de acordo com o número da versão (existe um pacote apt chamado golang-go, porém este costuma estar desatualizado)\n``` sh\nsudo rm -rf /usr/local/go \nwget https://go.dev/dl/go1.23.1.linux-amd64.tar.gz\nsudo tar -C /usr/local -xzf go1.23.1.linux-amd64.tar.gz\nrm go1.23.1.linux-amd64.tar.gz\n```\n\n### Chave SSH\n\nPreencha seu email antes de digitar o comando, confirme/insira os passos de senha.\n\n``` sh\nssh-keygen -t ed25519 -C \"your@email.com\"\neval \"$(ssh-agent -s)\"\nssh-add ~/.ssh/id_ed25519\necho\ncat ~/.ssh/id_ed25519.pub\n```\ncopie a chave no final da execução, aí é só [colar no github](https://github.com/settings/ssh/new)\n\n\n\n"},{"slug":"c4-diagrams","category":"shards","title":"Diagrama C4","tags":["draft","links"],"body":"\r\n## Documentação de código\r\n\r\n[Desvendando arquitetura de sistemas com o modelo c4](https://www.linkedin.com/pulse/desvendando-arquitetura-de-sistemas-com-o-modelo-c4-um-de-oliveira-ayvof/)"},{"slug":"data-types","category":"shards","title":"Tipos de dados","tags":["draft","data types"],"body":""},{"slug":"function-or-method","category":"shards","title":"Function or method?","tags":["draft","function","method"],"body":""},{"slug":"strings","category":"shards","title":"Strings","tags":["draft","strings"],"body":""},{"slug":"variables","category":"shards","title":"Variáveis e Constantes","tags":["draft","variables","constants"],"body":""}]