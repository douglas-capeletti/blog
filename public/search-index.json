[{"slug":"everything-about-docker","category":"blog","title":"[WIP] Como funciona o Docker?","tags":["docker","containers"],"body":"\n## O que s√£o Containers?\n\nContainers s√£o uma forma de virtualiza√ß√£o de sistemas operacionais.\nCada container √© um processo isolado do sistema operacional.\nContainers s√£o isolados uns dos outros, mas compartilham o mesmo kernel.\nContainers s√£o mais leves que m√°quinas virtuais por virtualizar somente parte do sistema operacional ao inv√©s de um SO inteiro\nContainers s√£o port√°teis.\nContainers s√£o escal√°veis.\nContainers s√£o descart√°veis.\n\n### Namespaces\n\nUsado para isolamento de processos, usu√°rios, rede, file system, etc.\ncada container tem seu pr√≥prio namespace.\n\n### Cgroups\n\nUsado para limitar e isolar recursos, exemplo: Esse processo/namespace vai utilizar s√≥:\n\n* memory=500mb\n* cpu_shares=512\n\n### Overlay File Systems (OFS)\n\nUsado para criar e modificar imagens, atrav√©s deste mecanismo que o docker reutiliza camadas/partes (_layers_) de um uma imagem ou depend√™ncias em todos os containers que precisarem, sem a necessidade de duplicar a informa√ß√£o\n\no container contem uma parte com comada(s) de estado imut√°vel, e uma de leitura e escrita\n\n### Dockerfile\n\ndescri√ß√£o de quais os comandos ser√£o executados ao criar o container para que ele funcione da forma esperada\n\n``` yaml\n  FROM: ubuntu:latest\n  RUN: ./build-script\n  EXPOSE: 8080\n```\n\na cada nova execucao o Dockerfile √© gerada uma nova imagem\n\ntodas as imagens ficam armazenadas no registry para poderem ser reutilizadas no futuro.\n\nao executar o Dockerfile, √© feito um pull desta imagem\n\nao efetuar um commit dentro de uma imagem docker, √© possivel gerar uma imagem nova a partir de uma j√° existe em execu√ß√£o, tirando proveito dos dados presentes na camada de leitura e escrita, assim feito um push desta imagem (tipo Git, um grande repo de imagens).\n\n### Client - Host\n\n* Host\n  * Daemon - API\n  * Network (entre containers)\n  * Volumes (fora do container, dado persistente)\n  * Cache (registry)\n\n* Client\n  * Containers\n  * Volumes\n  * Network\n\n## Comandos Docker\n\nEstado do processo docker (process status - ps)\nlista de todos os containers rodando no docker\n\n``` sh\n  docker ps\n```\n\n### Parametros √∫teis\n\n| Parametro | Fun√ß√£o                                                                       |\n| --------- | ---------------------------------------------------------------------------- |\n| -a        | incluir containers que n√£o estao mais rodando                                |\n| -q        | s√≥ o id do container, √∫til para usar de dado de entrada para outros comandos |\n\n### Rodando coisas no Docker\n\nCome√ßando do b√°sico\n\n``` sh\n  docker run hello-world\n```\n\n### par√¢metros √∫teis\n\n| Parametro | Fun√ß√£o                                               |\n| --------- | ---------------------------------------------------- |\n| -d        | destravar o terminal e roda o container em backgroud |\n| -e        | passar vari√°veis de ambiente                         |\n| -i        | modo interativo, mant√©m o stdin                      |\n| -p        | mapeamento de portas docker -> m√°quina local         |\n| -t        | alocar um tty para acessar o container               |\n| -v        | vincular volumes ao container                        |\n| -rm       | remove o container assim que ele cair                |\n| --name    | define um nome para o container                      |\n\n\nEntrando em um container\nobs.:  \"-it\"  ==  \"-i -t\" \n\n``` sh\n  docker run -it ubuntu bash\n```\n\nAcessando localmente algo que est√° no docker\npelo par√¢metro -p mapeamos a porta 80 de dentro do docker para a porta 8080 da maquina local\n\n``` sh\n  docker run -p 8080:80 nginx\n```\n\nassim podemos acessar o nginx [localmente atrav√©s da porta 8080](http://localhost:8080)\n\n\nos containers tambem podem ser nomeados para serem removidos pelo nome dado a eles e nao pelo nome gerado\n\n``` sh\n  docker run -d -p 8080:80 --name server nginx\n```\n\nagora o nginx esta rodando e o container se chama _server_ e pode ser referenciado desta forma.\npara acessar um container j√° em execu√ß√£o, utilizamos o exec\n\n``` sh\n  docker exec -it server bash\n```\n\n### Bind mounts \nmapeamento de pastas para dentro de um container atraves de _volumes_\nPrimeiro criando um arquivo na m√°quina local\n\n```` html\n  # ~/Projects/files/index.html\n  <html>\n  <h1>Custom Server Title</h1>\n  <br>\n  <h2>Welcome to the server!!<h2>\n  </html>\n````\n\ndepois mapeando este volume arquivo para um diretorio dentro do container\nObs.: a estrutura do container muda de acordo com a imagem usada, caso nao saiba a estrutura do container em utilizacao, pesquise ou entre nele via bash para ver\n\n``` sh\n  docker run -d -p 8080:80 -v ~/Projects/files/:/usr/share/nginx/html --name server nginx\n```\n\ntip: usar guia anonima para nao ter problemas com cache\ntip(2): da pra usar \"$(pwd)\" no path do comando para referenciar o diretorio atual\n\n\nA forma mais elegante e atual de executar essa mesma a√ß√£o\n\n``` sh\n  docker run -d -p 8080:80 --mount type=bind,source=~/Projects/files/,target=/usr/share/nginx/html --name server nginx\n```\n\ndiferen√ßas: --mount √© mais explicito o bind, se o source for incorreto, o -v cria o diretorio novo, o --mount da erro\n\n...\n#### #todo\n* ver diferencas de docker [kill | stop | rm];\n"},{"slug":"how-to-compare-dates-in-javascript","category":"blog","title":"How to compare dates in JavaScript","description":"How to compare dates in JavaScript natively using the Date Object, without using any third-party libraries.","tags":["javascript"],"body":"\nWorking with dates in JavaScript can be tricky to say the least. Recently I needed to compare two dates with one another to see which was greater than, less than, etc.\n\nIn my particular use case, I was using a date-picker that was returning a string like `01/28/2020`. I needed to see if this date was `>=` to the current day.\n\nThe first thing I needed to do was convert this string into a JavaScript Date Object.\n\n```js\nconst date: new Date(\"01/28/2020\");\nconsole.log(date);\n// Tue Jan 28 2020 00:00:00 GMT-0500 (Eastern Standard Time)\n```\n\nThen, compare this date with the current day:\n\n```js\nconst compareDate = new Date(\"01/28/2020\");\nconst today = new Date();\nconsole.log(compareDate >= today);\n// false\n```\n\nThe issue is that even though the dates are the same, the times are not.\n\n```js\nconst compareDate = new Date(\"01/28/2020\");\nconst today = new Date();\nconsole.log(\"compareDate: \", compareDate);\nconsole.log(\"today: \", today);\n// compareDate:  Tue Jan 28 2020 00:00:00 GMT-0500 (Eastern Standard Time)\n// today:  Tue Jan 28 2020 21:33:27 GMT-0500 (Eastern Standard Time)\n```\n\nNotice how `compareDate` has all zero's for time. The difference in time is the reason why this comparison fails. To fix this, we need to create the current day without time. We do this by instantiating a new JS Date object by individually passing in the year, month and day.\n\n```js\nconst todayWithoutTime = new Date(\n  new Date().getFullYear(),\n  new Date().getMonth(),\n  new Date().getDate()\n);\nconsole.log(\"todayWithoutTime: \", todayWithoutTime);\n// todayWithoutTime:  Tue Jan 28 2020 00:00:00 GMT-0500 (Eastern Standard Time)\n```\n\nSo let's try our comparison again.\n\n```js\nconst compareDate = new Date(\"01/28/2020\");\nconst todayWithoutTime = new Date(\n  new Date().getFullYear(),\n  new Date().getMonth(),\n  new Date().getDate()\n);\nconsole.log(compareDate >= todayWithoutTime);\n// true\n```\n\nThat's it. Just remember that when comparing dates in JavaScript it is vital to factor in the time. üòé\n"},{"slug":"introducing-astro","category":"blog","title":"Introducing Astro: Ship Less JavaScript","description":"We're excited to announce Astro as a new way to build static websites and deliver lightning-fast performance without sacrificing a modern developer experience.","tags":["astro"],"body":"\nThere's a simple secret to building a faster website ‚Äî _just ship less_.\n\nUnfortunately, modern web development has been trending in the opposite direction‚Äîtowards _more._ More JavaScript, more features, more moving parts, and ultimately more complexity needed to keep it all running smoothly.\n\nToday I'm excited to publicly share Astro: a new kind of static site builder that delivers lightning-fast performance with a modern developer experience. To design Astro, we borrowed the best parts of our favorite tools and then added a few innovations of our own, including:\n\n- **Bring Your Own Framework (BYOF):** Build your site using React, Svelte, Vue, Preact, web components, or¬†just plain ol' HTML + JavaScript.\n- **100% Static HTML, No JS:** Astro renders your entire page to static HTML, removing all JavaScript from your final build by default.\n- **On-Demand Components:** Need some JS? Astro can automatically hydrate interactive components when they become visible on the page. If the user never sees it, they never load it.\n- **Fully-Featured:** Astro supports TypeScript, Scoped CSS, CSS Modules, Sass, Tailwind, Markdown, MDX, and any of your favorite npm packages.\n- **SEO Enabled:** Automatic sitemaps, RSS feeds, pagination and collections take the pain out of SEO and syndication.\n\nThis post marks the first public beta release of Astro. **Missing features and bugs are still to be expected at this early stage.** There are still some months to go before an official 1.0 release, but there are already several fast sites built with Astro in production today. We would love your early feedback as we move towards a v1.0 release later this year.\n\n> To learn more about Astro and start building your first site, check out [the project README.](https://github.com/snowpackjs/astro#-guides).\n\n## Getting Started\n\nStarting a new project in Astro is easy:\n\n```shell\n# create your project\nmkdir new-project-directory\ncd new-project-directory\nnpm init astro\n\n# install your dependencies\nnpm install\n\n# start the dev server and open your browser\nnpm run dev\n```\n\n> To learn more about Astro and start building your first site, check out [the project README.](https://github.com/snowpackjs/astro#-guides).\n\n## How Astro Works\n\nAstro works a lot like a static site generator. If you have ever used Eleventy, Hugo, or Jekyll (or even a server-side web framework like Rails, Laravel, or Django) then you should feel right at home with Astro.\n\nIn Astro, you compose your website using UI components from your favorite JavaScript web framework (React, Svelte, Vue, etc). Astro renders your entire site to static HTML during the build. The result is a fully static website with all JavaScript removed from the final page. No monolithic JavaScript application required, just static HTML that loads as fast as possible in the browser regardless of how many UI components you used to generate it.\n\nOf course, sometimes client-side JavaScript is inevitable. Image carousels, shopping carts, and auto-complete search bars are just a few examples of things that require some JavaScript to run in the browser. This is where Astro really shines: When a component needs some JavaScript, Astro only loads that one component (and any dependencies). The rest of your site continues to exist as static, lightweight HTML.\n\nIn other full-stack web frameworks this level of per-component optimization would be impossible without loading the entire page in JavaScript, delaying interactivity. In Astro, this kind of [partial hydration](https://addyosmani.com/blog/rehydration/) is built into the tool itself.\n\nYou can even [automatically defer components](https://codepen.io/jonneal/full/ZELvMvw) to only load once they become visible on the page with the `client:visible` directive.\n\nThis new approach to web architecture is called [islands architecture](https://jasonformat.com/islands-architecture/). We didn't coin the term, but Astro may have perfected the technique. We are confident that an HTML-first, JavaScript-only-as-needed approach is the best solution for the majority of content-based websites.\n\n> To learn more about Astro and start building your first site, check out [the project README.](https://github.com/snowpackjs/astro#-guides)\n\n## Embracing the Pit of Success\n\n> A well-designed system makes it easy to do the right things and annoying (but not impossible) to do the wrong things<div class=\"source\"><p>‚Äì Jeff Atwood</p>[Falling Into The Pit of Success](https://blog.codinghorror.com/falling-into-the-pit-of-success/)</div>\n\nPoor performance is often framed as a failure of the developer, but we respectfully disagree. In many cases, poor performance is a failure of tooling. It should be difficult to build a slow website.\n\nAstro's main design principle is to lead developers into what [Rico Mariani](https://twitter.com/ricomariani) dubbed \"the pit of success\". It is our goal to build every site \"fast by default\" while also delivering a familiar, modern developer experience.\n\nBy building your site to static HTML by default, Astro makes it difficult (but never impossible üòâ) to build a slow site.\n\n## Long-Term Sustainability\n\nAstro is built by the team of open source developers behind [Snowpack](https://snowpack.dev) and [Skypack](https://skypack.dev), with additional contributions from the community.\n\n**Astro is and always will be free.** It is an open source project released under the [MIT license](https://github.com/snowpackjs/astro/blob/main/LICENSE).\n\nWe care deeply about building a more sustainable future for open source software. At the same time, we need to support Astro's development long-term. This requires money (donations alone aren't enough.)\n\nWe're inspired by the early success of projects like [Tailwind](https://tailwindcss.com/), [Rome](https://rome.tools/), [Remix](https://remix.run/), [Ionic](https://ionicframework.com/), and others who are experimenting with long-term financial sustainability on top of Open Source. Over the next year we'll be exploring how we can create a sustainable business to support a 100% free, open source Astro for years to come.\n\nIf your company is as excited about Astro as we are, [we'd love to hear from you.](https://astro.build/chat)\n\nFinally, I'd like to give a **HUGE** thanks to the 300+ developers who joined our earliest private beta. Your feedback has been essential in shaping Astro into the tool it is today. If you're interested in getting involved (or just following along with development) please [join us on Discord.](https://astro.build/chat)\n\n> To learn more about Astro and start building your first site, check out [the project README.](https://github.com/snowpackjs/astro#-guides)\n"}]