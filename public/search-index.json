[{"slug":"how-docker-works","category":"drafts","title":"Como Docker funciona","tags":["docker","containers"],"body":"\n## O que são Containers?\n\nContainers são uma forma de virtualização de sistemas operacionais.\nCada container é um processo isolado do sistema operacional.\nContainers são isolados uns dos outros, mas compartilham o mesmo kernel.\nContainers são mais leves que máquinas virtuais por virtualizar somente parte do sistema operacional ao invés de um SO inteiro\nContainers são portáteis.\nContainers são escaláveis.\nContainers são descartáveis.\n\n### Namespaces\n\nUsado para isolamento de processos, usuários, rede, file system, etc.\ncada container tem seu próprio namespace.\n\n### Cgroups\n\nUsado para limitar e isolar recursos, exemplo: Esse processo/namespace vai utilizar só:\n\n* memory=500mb\n* cpu_shares=512\n\n### Overlay File Systems (OFS)\n\nUsado para criar e modificar imagens, através deste mecanismo que o docker reutiliza camadas/partes (_layers_) de um uma imagem ou dependências em todos os containers que precisarem, sem a necessidade de duplicar a informação\n\no container contem uma parte com comada(s) de estado imutável, e uma de leitura e escrita\n\n### Dockerfile\n\ndescrição de quais os comandos serão executados ao criar o container para que ele funcione da forma esperada\n\n``` yaml\n  FROM: ubuntu:latest\n  RUN: ./build-script\n  EXPOSE: 8080\n```\n\na cada nova execucao o Dockerfile é gerada uma nova imagem\n\ntodas as imagens ficam armazenadas no registry para poderem ser reutilizadas no futuro.\n\nao executar o Dockerfile, é feito um pull desta imagem\n\nao efetuar um commit dentro de uma imagem docker, é possivel gerar uma imagem nova a partir de uma já existe em execução, tirando proveito dos dados presentes na camada de leitura e escrita, assim feito um push desta imagem (tipo Git, um grande repo de imagens).\n\n### Client - Host\n\n* Host\n  * Daemon - API\n  * Network (entre containers)\n  * Volumes (fora do container, dado persistente)\n  * Cache (registry)\n\n* Client\n  * Containers\n  * Volumes\n  * Network\n"},{"slug":"how-use-docker","category":"drafts","title":"Como usar o Docker","tags":["docker","containers"],"body":"\n## Comandos Docker\n\nEstado do processo docker (process status - ps)\nlista de todos os containers rodando no docker\n\n``` sh\n  docker ps\n```\n\n### Parametros úteis\n\n| Parametro | Função                                                                       |\n| --------- | ---------------------------------------------------------------------------- |\n| -a        | incluir containers que não estao mais rodando                                |\n| -q        | só o id do container, útil para usar de dado de entrada para outros comandos |\n\n### Rodando coisas no Docker\n\nComeçando do básico\n\n``` sh\n  docker run hello-world\n```\n\n### parâmetros úteis\n\n| Parametro | Função                                               |\n| --------- | ---------------------------------------------------- |\n| -d        | destravar o terminal e roda o container em backgroud |\n| -e        | passar variáveis de ambiente                         |\n| -i        | modo interativo, mantém o stdin                      |\n| -p        | mapeamento de portas docker -> máquina local         |\n| -t        | alocar um tty para acessar o container               |\n| -v        | vincular volumes ao container                        |\n| -rm       | remove o container assim que ele cair                |\n| --name    | define um nome para o container                      |\n\n\nEntrando em um container\nobs.:  \"-it\"  ==  \"-i -t\" \n\n``` sh\n  docker run -it ubuntu bash\n```\n\nAcessando localmente algo que está no docker\npelo parâmetro -p mapeamos a porta 80 de dentro do docker para a porta 8080 da maquina local\n\n``` sh\n  docker run -p 8080:80 nginx\n```\n\nassim podemos acessar o nginx [localmente através da porta 8080](http://localhost:8080)\n\n\nos containers tambem podem ser nomeados para serem removidos pelo nome dado a eles e nao pelo nome gerado\n\n``` sh\n  docker run -d -p 8080:80 --name server nginx\n```\n\nagora o nginx esta rodando e o container se chama _server_ e pode ser referenciado desta forma.\npara acessar um container já em execução, utilizamos o exec\n\n``` sh\n  docker exec -it server bash\n```\n\n### Bind mounts \nmapeamento de pastas para dentro de um container atraves de _volumes_\nPrimeiro criando um arquivo na máquina local\n\n```` html\n  # ~/Projects/files/index.html\n  <html>\n  <h1>Custom Server Title</h1>\n  <br>\n  <h2>Welcome to the server!!<h2>\n  </html>\n````\n\ndepois mapeando este volume arquivo para um diretorio dentro do container\nObs.: a estrutura do container muda de acordo com a imagem usada, caso nao saiba a estrutura do container em utilizacao, pesquise ou entre nele via bash para ver\n\n``` sh\n  docker run -d -p 8080:80 -v ~/Projects/files/:/usr/share/nginx/html --name server nginx\n```\n\ntip: usar guia anonima para nao ter problemas com cache\ntip(2): da pra usar \"$(pwd)\" no path do comando para referenciar o diretorio atual\n\n\nA forma mais elegante e atual de executar essa mesma ação\n\n``` sh\n  docker run -d -p 8080:80 --mount type=bind,source=~/Projects/files/,target=/usr/share/nginx/html --name server nginx\n```\n\ndiferenças: --mount é mais explicito o bind, se o source for incorreto, o -v cria o diretorio novo, o --mount da erro\n\n### Como criar volumes\n\n``` sh\n  docker create volume meuVolume\n```\n\nagora para ver os detalhes do volume\n\n``` sh\n  docker volume inspect meuVolume  \n```\n\nresultado:\n\n``` json\n  [\n    {\n        \"CreatedAt\": \"2023-09-28T16:40:47-03:00\",\n        \"Driver\": \"local\",\n        \"Labels\": null,\n        \"Mountpoint\": \"/var/lib/docker/volumes/meuVolume/_data\",\n        \"Name\": \"meuVolume\",\n        \"Options\": null,\n        \"Scope\": \"local\"\n    }\n  ]\n```\nagora da pra usar o volume criado igual qualquer outro e estes arquivos vao ser compartilhados pelos containers que utilizarem estes volumes\n\n``` sh\n  docker run -d -p 8080:80 --mount source=meuVolume,target=/app --name server nginx\n```\nou\n``` sh\n  docker run -d -p 8080:80 -v meuVolume:/app --name server nginx\n```\n\nporem criando varios volumes, ao longo do tempo vamos tomando muito espaco em disco, para limpar os volumes do docker, use:\n\n``` sh\n  docker volume prune\n```\n\n## Dockerfile\n\npodemos criar arquivos docker para criar uma imagem personalizada de acordo com a nossa necessidade\n\n``` yaml\n  # imagem base usada para a criacao da nova imagem\n  FROM nginx:latest\n\n  # comandos a serem executados na criacao da imagem\n  RUN apt update\n  RUN apt install -y vim\n```\n\npara executarmos este docker file, abrimos o terminal na pasta onde o arquivo se encontra e executamos o comando:\n\n``` sh\n  docker build -t nginx-vim:latest .\n```\n\no parametro '-t' define a tag da imagem, assim como usamos antes o nginx antes, agora temos uma versao do 'nginx' com o vim instalado chamada de 'nginx-vim'\n\njá o '.' no final se refere a localizacao do arquivo Dockerfile, como estamos com o terminal aberto no mesmo diretorio do arquivo Dockerfile, usamos o ponto, caso nao seja o caso, devemos usar o caminho relativo do arquivo\n\n...\n#### #todo\n* ver diferencas de docker [kill | stop | rm];\n"},{"slug":"golang","category":"notes","title":"Golang - Resumo Rápido (wip)","tags":["golang","programming languages"],"body":"\n## Caracteristicas\n- linguagem compilada direto para binário\n- binário grande\n- linguagem simples \n- projetada para concorrencia\n- variáveis ou métodos criados PRECISAM ser utilizados ou não irá compilar \n- [como instalar em qualquer plataforma](http://go.dev/doc/install)\n\n### Padrões de uso da linguagem\n- letra inicial maiúscula em uma função determina que ela será publica\n- não há getters nem setters, caso necessário uso de um get, utilize a declaracao do campo com letra minuscula e crie um método com o mesmo nome do campo porém com letra maiúscula, desta forma a função será exportado e quem utilizar não verá diferença, para o setter, utilize o padrão SetCampo para alterar o valor do campo caso necessário\n- ao nomear interfaces utilize verbos, Reader, Writter..., assim o método será o substantivo daquele verbo (Read, Write)\n- caso implemente uma conversão para um tipo conhecido, utilize o nome do tipo diretamente exemplo: String() e não ToString()\n- nomes de pacotes dever ser pequenos\n- utilize MixedCaps como padrão, iniciando ou não com maiúscula conforme visibilidade do médoto ou variável\n- estrutura de projeto\n``` yaml\n  moduleFolder:\n    cmd:\n      # como os pacotes são exportados individualmente\n      # o main fica separado para quem importar poder executar seu próprio main\n      - main.go       \n      \n```\n\n### Módulos & Pacotes\n``` yaml\n  Modulo: Coleção de pacotes\n    - Pacote:\n      - file.go\n    - Pacote:\n      - file.go\n      - file.go\n```\nComo criar um módulo\n```sh\n  go mod init myModule # ou github.com/<user>/<repo_do_modulo>\n```\noutput\n``` sh\n  module myModule\n\n  go 1.23 # active version\n```\n\n\nPacote Main <br>\ntodo pacote main precisa ter uma funcao chamada main, caso contrato terá um erro de compilação\n\n``` go\n  package main\n\n  import \"fmt\"\n\n  func main(){\n    fmt.Println(\"Hello World!\")\n  }\n```\n\nExecutar um programa go\n\n``` sh\n  # somente compilação (vai gerar o binário)\n  go build cmd/main.go\n  # execução do binário\n  ./main\n  # ou compilar e executar consecutivamente com o comando run\n  go run cmd/main.go\n```\n\n### Tipos\n\n### Tipos da dados básicos\n``` yaml\n  Booleano: \n    Default: false\n    - bool: true ou false\n  Ponto Flutuante:\n    Dafault: 0.0\n    - float32: 32 bits = -3.4e+38 to 3.4e+38\n    - float64: 64 bits = -1.7e+308 to +1.7e+308\n  Caracter:\n    Default: 0\n    - byte: alias for uint8\n    - rune: alias for int32\n  Texto:\n    Default: ''\n    - string: coleção de bytes UTF-8\n  Inteiro:\n    Default: 0\n    - int: tamanho depende da arquitetura do sistema 32 ou 64 bits\n    - int8: min -128 | max = -127\n    - int16: min = -32768 | max = -32767\n    - int32: min = -2147483648 | max = -2147483647\n    - int64: min = -9223372036854775808 | max = -9223372036854775807\n    - uint: 'u' vem de unassigned (sem atribuição de sinal) \n    - uint8: min = 0 | max = -255\n    - uint16: min = 0 | max = -65535\n    - uint32: min = 0 | max = -4294967295\n    - uint64: min = 0 | max = -18446744073709551615\n```\n\n#### Tipos de variáveis\n``` go\n  const myConst // imutável ou constante\n  var myVar  // mutável porém de tipagem forte e estática\n\n  myVar = \"some value\" // tipo inferido (string)\n  myVar = 10 // erro \n```\n\n### Declaração de variáveis\n``` go\n  var intNum int\n  anotherInt := 0\n  var some, other = 1, 2\n  look, again := 3, 4\n  // only one way for constants, sorry\n```\n\n### STRINGS, RUNES & BYTES\nStrings em go são imutáveis e naturalmente UTF-8, e ocupam 7 bits + 1 bit de sinal, porém UTF-8 tem um encoding dinâmico que pode se extender até 32 bits, cobrindo UTF-32, e podendo armazenar caracteres chineses, emojis e outros símbolos,\n\nStrings em go são uma coleção de Runas ou uint8 devido o encoding, porém\n``` go\n  var simpleString string = \"Hello \\nworld!\"\n  var stringBlock string = `Hello\n  world!`\n\n  fmt.Println(simpleString) // mesmo resultado\n  fmt.Println(stringBlock) // nos dois\n\n  fmt.Println(len(\"atenção\")) // 9 | número de bytes em ASCII 256\n  fmt.Println(len(\"atencao\")) // 7 | parece estar certo, mas não funciona sempre\n\n  import \"unicode/utf8\"\n  fmt.Println(utf8.RuneCountInString(\"atenção\")) // resultado correto sempre\n\n\tvar myString = \"atenção\"\n  // Ao buscar o 'a' teremos o valor correto dele na tabela ascii\n\tvar stringIndex uint8 = myString[0]\n\tfmt.Println(stringIndex) // 97\n\n  // Ao buscar o 'ç' teremos o valor do primeiro byte\n  // porém como 'ç' precisa de mais de um byte, o valor correto seria 231\n\tvar stringIndex4 uint8 = myString[4]\n\tfmt.Println(stringIndex4) // 167\n\tfor i, v := range myString {\n\t\tfmt.Println(i, v)\n\t}\n\t/*\n\t\t0 97\n\t\t1 116\n\t\t2 101\n\t\t3 110 \n\t\t4 231 <- ocupa o espaço do 4 e do 5\n\t\t6 227 <- por isso aqui é 6\n\t\t8 111\n\t*/\n\n  var myRune rune = 'a'\n  fmt.Println(myRune) // 97 | int32 ele imprime o valor numérico\n\n\t// Manipulando Strings\n\tvar strSlice = []string{\"H\", \"e\", \"l\", \"l\", \"o\"}\n\tvar concatStr = \"\"\n\tfor i := range strSlice {\n\t\t// podemos fazer uma concatenação básica\n\t\t// a cada iteração uma nova string será gerada\n\t\tconcatStr += strSlice[i]\n\t}\n\n\tvar strBuilder strings.Builder\n\tfor i := range strSlice {\n\t\t// ou usando um string builder, melhor alternativa\n\t\tstrBuilder.WriteString(strSlice[i])\n\t}\n\tfmt.Println(strBuilder.String())\n```\n\n### Cálculos básicos\n``` go\n  // cast é necessário para fazer os cálculo\n  var numFloat32 float32 = 10.1\n  var numInt32 int32 = 2\n  var result float32 = numFloat32 + float32(numInt32)\n  fmt.Println(result)\n\n  var numInt1 int = 3\n  var numInt2 int = 2\n  fmt.Println(numInt1/numInt2) // 1 | arredondamento para int\n  fmt.Println(numInt1%numInt2) // 1 | operação com resto de divisão\n\n  var myBoolean bool = false // como alquer linguagem, simples\n```\n\n### Declarando Funções\n\n``` go\n  // Forma comum vista em outras linguagens\n  func functionName(param1 string, param2 int) string {\n    return \"result\"\n  }\n\n  // returnando mais de um resultado\n  func multipleReturns(param1 string, param2 int) (string, int) {\n    return \"result\", 10\n  }\n\n  // ao chamar a funcao devemos receber os dois dados\n  var first, second = multipleReturns(\"something\", 1)\n\n  import \"errors\" // pacote de error da biblioteca padrão\n  // golang não tem try-catch então todos os errors são tratados no retorno da função\n  func withError(wrong bool) bool, error {\n    var err error // default: nil\n    if wrong {\n      err = errors.New(\"Something went wrong\")\n    }\n    return err, wrong\n  }\n  // devemos receber este erro e verificar se ele tem algo\n  err, response := withError(true)\n  // forma padrão de lidar com erros\n  if err!=nil {\n    fmt.Printf(err.Error())\n  }\n\n  // ou podemos ignorar este erro explicitamente usando '_' \n  // por padrão devemos retornar primeiro o erro para que ele não seja ignorado acidentalmente\n  _, response2 := withError(false)\n\n  // funcoes também podem ser atribuídas a objetos\n  func (b ball) roll() {\n    b.position++\n  }\n  // assim quando declaramos uma nova bola\n  newBall := ball.New()\n  // temos o método novo acessivel a ele\n  // isso permite estender estruturas de bibliotecas externas, ou até mesmo internas\n  // podemos atribuir métodos novos para o tipo string por exemplo\n  newBall.roll()\n```\n\n### Outras estruturas de controle\n``` go\n\t// if, switch, for, não tem parêntesis\n\tvalue := \"something\"\n\n\tif value == \"Hi\" {\n\t\tfmt.Println(\"It's hi\")\n\n\t\t// else if e else, tem que estar na mesma linha das chaves\n\t} else if value != \"something\" {\n\t\tfmt.Println(\"it's not something\")\n\n\t} else {\n\t\tfmt.Println(\"it's \" + value)\n\t}\n\n\t// no switch, o break é inplicito sobre cada condição\n\tswitch {\n\tcase value == \"Hi\":\n\t\tfmt.Println(\"It's hi\")\n\n\tcase value != \"something\":\n\t\tfmt.Println(\"it's not something\")\n\n\tdefault:\n\t\tfmt.Println(\"it's \" + value)\n\t}\n\n  // ele também pode ser condicional, atribuindo uma variável diretamente\n\tswitch value {\n\tcase \"Hi\":\n\t\tfmt.Println(\"It's hi\")\n\n  // podendo validar mais de um valor para cada cenário\n\tcase \"another thing\", \"anything\":\n\t\tfmt.Println(\"it's not something\")\n\n\tdefault:\n\t\tfmt.Println(\"it's \" + value)\n\t}\n```\n\n### Estruturas de dados\n``` go\n  // ARRAYS\n  // Tamanho fixo | mesmo tipo de dados | indexável | contínuo na memória\n  var intArr[3]int32\n  intArr[1] = 123 // atribuindo no index\n  fmt.Println(intArr[0]) // imprimindo posicao 0\n  fmt.Println(intArr[1:3]) // imprimindo de 1 até 2 (intervalo aberto no 3)\n\n  fmt.Println(&intArr[0]) // imprimindo o endereço de memória\n  fmt.Println(&intArr[1]) // assim temos como ver que eles ficam\n  fmt.Println(&intArr[2]) // um do lado do outro\n\n  // poderiamos ter inicializado o array assim também\n  anotherIntArr := [3]int32{3, 2, 1}\n  fmt.Println(anotherIntArr[0:3])\n```\n``` go\n  // SLICES\n  // Wrapper para array, ou um array com funcionalidades extras\n  // ao omitir o tamanho, temos um slice, que será gerado dinamicamente\n  intSlice := []int32{1, 2, 3}\n  // tamanho do array, é a quantidade de items, capacidade, é a memória alocada para o array\n  fmt.Printf(\"O tamanho do array é %v porém a capacidade é %v = \", len(intSlice), cap(intSlice)) // 3 & 3\n  fmt.Println(intSlice)\n\n  // podemos adicionar valores extras\n  intSlice = append(intSlice, 7)\n  // porém ao exceder a capacidade do array original, a capacidade é DOBRADA\n  // porém não podemos acessar estes valores que estão fora do array\n  fmt.Printf(\"O tamanho do array é %v porém a capacidade é %v = \", len(intSlice), cap(intSlice)) // 4 & 6\n  fmt.Println(intSlice)\n\n  // poderiamos criar um novo array especificando tamanho e capacidade\n  // make é uma função 'fábrica' para os tipos básicos\n  // int[] é o tipo, 3 o tamanho, 8 a capacidade\n  var intSlice2 []int32 = make([]int32, 3, 8)\n\n  // podemos inserir os dados no FIM de outro array via funcao append com o operador spread (...)\n  intSlice2[0] = 10\n  intSlice2 = append(intSlice, intSlice2...) // [10, 0, 0, 1, 2, 3, 7]\n  fmt.Println(intSlice2)\n\n  // iterando...\n  for index, value := range intSlice2 {\n    fmt.Println(\"Index: \" + index + \" Value: \" + value)\n  }\n```\n``` go\n  // MAPS\n  \n  // podemos criar um mapa desta forma\n  var myMap map[string]uint8 = make(map[string]uint8)\n  fmt.Println(myMap)\n\n  // ou diretamente atribuindo valores\n  MyMap2 := map[string]uint8}{\"James\":5 \"Tiberius\":8 \"Kirk\":4 }\n  fmt.Println(myMap2[\"James\"]) // 7\n  \n  // nesse caso, ele retorna o valor padrão do tipo, nesse caso do uint8 é 0\n  fmt.Println(myMap2[\"Spock\"])\n  // podemos deletar um valor usando a funcao delete\n  delete(myMap2, \"Tiberius\")\n\n  // para saber se o valor estava no mapa ou ele era realmente 0\n  // temos um segundo no mapa\n  var nameLen, found = myMap2[\"Spock\"] // 0 & false\n  if  found {\n    fmt.Println(\"The name length is \" + nameLen)\n  }\n\n  // iterando...\n  for key, value := range myMap2 {\n    fmt.Println(\"Name: \" + key + \" Name length: \" + value)\n  }\n```\n\n### Iterando\nponto importante, golang não tem 'while', então existem variações no for para lidar com todos os cenários necessários\n``` go\n  // Loop basico 'while'\n  var i int = 0\n  for i<10 {\n    fmt.Println(i)\n    i += 1\n  }\n\n  // Loop sem condição \n  i=0 // resetando\n  for {\n    // removendo esse if interno, loop infinito\n    if i>=10{\n      break\n    }\n    fmt.Println(i)\n    i += 1\n  }\n\n  // for clássico\n  for i=0; i<10; i++ {\n    fmt.Println(i)\n    i += 1\n  }\n\n  // for range (ou foreach in range)\n  intSlice := []int32{1, 2, 3}\n  for index, value := range intSlice {\n    fmt.Println(\"Index: \" + index + \" Value: \" + value)\n  }\n\n  // podemos ignorar o indice também\n  for _, value := range intSlice {\n    fmt.Println(\"Index: \" + index + \" Value: \" + value)\n  }\n```\n\n### Structs & Interfaces\nStruct em go nada mais é que um objeto, ele contém atributos e pode conter funções/métodos internos.\nMas go é orientado a objetos? Não necessariamente, em go não existe herança.\nInterfaces em go tem um comportamento mais 'passivo', ao definir as funções contidas em uma interface, toda struct que conter estas funções vai ser considerada como compatível com a interface, sem a necessidade de explicitamente atribuir a interface para aquela struct, desta forma podemos trabalhar melhor com bibliotecas externas definindo interfaces que seja compatíveis com structs já criadas externamente e criando novas structs compativeis com estas mesmas interfaces\n\n``` go\n  // structs podem ser declaradas de forma anonima\n  // porém assim não podem ser reutilizadas\n  var person = struct{\n    name string\n    age uint8\n  }{\"Spock\", 83}\n\n  // esta é a forma comum de declarar structs\n  type owner struct {\n    name string\n  }\n\n  type gasCar struct {\n    kml     uint8\n    tankCap uint8\n    owner   // caso tipo e variavel tenham o mesmo nome, podemos omitir\n  }\n\n  // desta forma atribuimos uma funcao para a struct gasEngine\n  func (e gasCar) kmLeft() uint {\n    return uint(e.tankCap) * uint(e.kml)\n  }\n\n  type eletricCar struct {\n    kpkwh      uint8\n    batteryCap uint8\n    owner      owner // podemos por ambos sem problemas também\n  }\n\n  // desta forma atribuimos uma funcao para a struct gasEngine\n  func (e eletricCar) kmLeft() uint {\n    return uint(e.batteryCap) * uint(e.kpkwh)\n  }\n\n  // ao declarar a interface, tanto o carro a gasolina quanto o eletrico\n  // poderão satisfazer este requisito e serem considerados somente carros\n  type car interface {\n    kmLeft() uint\n  }\n\n  func willReachDestination(c car, distance uint) bool {\n    return c.kmLeft() >= distance\n  }\n\n  func main() {\n    // uma struct pode ser inicializada desta forma\n    var myCar gasCar = gasCar{kml: 15, tankCap: 40, owner: owner{\"Someone\"}}\n    // e ser alterada desta forma (pegando estrada né)\n    myCar.kml = 20\n    fmt.Println(myCar.kmLeft())\n\n    // nomes de variáveis podem ser omitidos, enviando os parametros em ordem\n    var myOtherCar eletricCar = eletricCar{4, 100, owner{\"Someone\"}}\n    fmt.Println(myOtherCar.kmLeft())\n\n    // ao usar a funcao podemos utilizar ambos os carros\n    // pois ambos satisfazem os requisitos da interface\n    var distance uint = 500\n    fmt.Println(\"Gas Car: \", willReachDestination(myCar, distance))\n    fmt.Println(\"Eletric car: \", willReachDestination(myOtherCar, distance))\n  }\n```\n\n## Tomorrow it's to time for POINTERS\n\n### TODO LIST\n- revisar ortografia\n- segmentar melhor os blocos de código\n- organizar melhor a ordem dos tópicos\n- revisar o tamanho dos títulos\n"},{"slug":"usefull-links","category":"shards","title":"Links úteis","tags":["documentation","arquitecture"],"body":"\n## Documentação de código\n\n[Desvendando arquitetura de sistemas com o modelo c4](https://www.linkedin.com/pulse/desvendando-arquitetura-de-sistemas-com-o-modelo-c4-um-de-oliveira-ayvof/)"}]